program triton
use nrtype
use constants
use interpolation
use trimod_sub
implicit none
!--------------------------------------------------------------------------------------------------------------------------------!
!                                                 READ ME
! The output file is automatically generated by the program and it is called output.dat
! The final result, i.e. the binding energy of the triton, is also printed on the terminal
! The user has to select the interaction and cutnumr (only with interaction=3)
! The starting energy e0 can be also changed. For example, with interaction=2 the binding energy is ~8.0 MeV and thus e0 can be
! set at -7.8 MeV. With interaction=3 the binding energy is ~7.2 MeV and a better value is e0=-7.0 MeV. This is not mandatory but
! improves the calculation, which otherwise will require many more iterations and larger values of iemax and itermax parameters
! N.B. if the starting energy is less than the binding energy, the algorithm will not find any bound state, for example, if the
! binding energy is -7.2 MeV and the starting energy is set at -7.6 MeV, the algorithm will not find the bound state
!
! Results:
!    interaction=1              ==>  BE = -7.74 MeV
!    interaction=2              ==>  BE = -8.03 MeV
!    interaction=3 (cutnumr=2)  ==>  BE = -7.20 MeV
!
!
! Input:
!
!    interaction: 1 = CD-Bonn, 2 = N4LO(500) EMN of 2017, 3 = N4LO(R=0.9) EKM of 2014
!    cutnumr: only with interaction=3, possible values=1,2,3,4,5
!
!
! Parameters:
!
!    nq  = number of q points in the interval [0,qmax] with q0 beeing the middle
!    np1 = number of p points in the interval [0,pmax] with p0 beeing the middle
!    np2 = number of p points in the interval [pmax,pcut] with pm beeing the middle
!    nptot = total number of p points as needed for the solution of the Lippmann-Schwinger equation in tmat
!    np  = number of p points for the spline interpolation
!    nx  = number of x points in the interval [-1.0,1.0]
!    m   = nucleon mass in MeV (defined in module constants)
!    mf  = nucleon mass in fm^-1 (defined in module constants)
!    e0  = starting energy in MeV
!    de  = energy step in MeV
!    iaf,ipf,iqf = indices for arbitrarily chosen alpha, p, and q points for the vector iteration procedure.
!                  They define the parameter "Ratio" printed in the output
!
!
! Principal global variables:
!
!    q = array of q points [fm^-1]
!    p = array of p points [fm^-1]
!    s1,s2 = spline elements
!    psi0  = starting vector at each energy
!    x1,x2 = vectors, x2 results from application ot the Faddeev kernel to x1
!    rold,rnew = ratios of x2 and x1
!    e   = energy values during the energy search [fm^-1]
!    eta = eigenvalue ot the Faddeev kernel
!    t   = the two-body off-shell t-matrix
!    ratmax,ratmin = the maximal and minimum ratios of x2 and x1 with respect to p and q variations
!    iemax = maximum limit for iteration over the energy
!    itermax = maximum limit for the vector iteration
!    nchmax = total number of channels alpha
!
! Programmer: Matteo Vorabbi
! Last update: 2022 December 16
!--------------------------------------------------------------------------------------------------------------------------------!
! Interaction parameters
integer(kind=i4b), parameter :: interaction=3,cutnumr=2

! Mesh points
integer(kind=i4b), parameter :: np1=16,np2=18,nptot=1+np1+np2,np=np1+1,nq=10,nx=10
real(kind=dp), parameter :: q0=1.0_dp,qmax=4.0_dp,p0=1.0_dp,pmax=1.5_dp*qmax+0.3_dp,pm=10.0_dp,pcut=50.0_dp

! Number of channels and iteration parameters
integer(kind=i4b), parameter :: iemax=20,itermax=50,nchmax=66,iaf=1,ipf=8,iqf=5
real(kind=dp), parameter :: e0=-11.0_dp,de=-0.1_dp

! Other variables
integer(kind=i4b) :: ia,ip,iq,ie,ip1,ip2,iter,ix,ia1,ia2,iqp,ic
integer(kind=i4b), dimension(nchmax,6) :: chan
real(kind=dp) :: emev,e2,c1,c2,c3,pi1,pi2,s,sh,shh,salph,fdenom,ratmax,ratmin,df
real(kind=dp), dimension(nq) :: q,q2,wq
real(kind=dp), dimension(nptot) :: p,p2,wp
real(kind=dp), dimension(nx) :: x,wx
real(kind=dp), dimension(nx,np,nq,nq) :: s1,s2
real(kind=dp), dimension(nchmax) :: sumv
real(kind=dp), dimension(nchmax,nchmax,nq,nq,nx) :: gfac
real(kind=dp), dimension(nchmax,np,nq) :: psi0,x1,x2,rold,rnew
real(kind=dp), dimension(iemax) :: e,eta,eig
real(kind=dp), dimension(nchmax,np) :: h
real(kind=dp), dimension(:), allocatable :: vec1,vec2,vec3,vec4,vec5,vec6
real(kind=dp), dimension(np,np) :: tnp_s,tnn_s,tnp_t,tnn_t,tnp_pp,tnp_mm,tnp_pm,tnp_mp,tnn_pp,tnn_mm,tnn_pm,tnn_mp
real(kind=dp), dimension(6,nptot,nptot) :: np_pot_0,nn_pot_0,np_pot_1,nn_pot_1,np_pot_2,nn_pot_2,np_pot_3,nn_pot_3,np_pot_4
real(kind=dp), dimension(6,nptot,nptot) :: nn_pot_4,np_pot_5,nn_pot_5,np_pot_6,nn_pot_6,np_pot_7,nn_pot_7,np_pot_8,nn_pot_8
real(kind=dp), dimension(np,np,nq) :: ts0,ts1,ts2,ts3,ts4,ts5,ts6,ts7,ts8,tt0,tt1,tt2,tt3,tt4,tt5,tt6,tt7,tt8
real(kind=dp), dimension(np,np,nq) :: tpp1,tmm1,tpm1,tmp1,tpp2,tmm2,tpm2,tmp2,tpp3,tmm3,tpm3,tmp3,tpp4,tmm4,tpm4,tmp4
real(kind=dp), dimension(np,np,nq) :: tpp5,tmm5,tpm5,tmp5,tpp6,tmm6,tpm6,tmp6,tpp7,tmm7,tpm7,tmp7,tpp8,tmm8,tpm8,tmp8

! Open output file

  open(oup,file='output.dat',status='replace')

! Write input parameters in the output file

  write(oup,10)
  write(oup,11) np1,np2,nptot,np,nq,nx
  write(oup,12) q0,qmax
  write(oup,13) p0,pmax
  write(oup,14) pm,pcut
  if (interaction == 1) then
     write(oup,26)
  else if (interaction == 2) then
     write(oup,27)
  else if (interaction == 3) then
     write(oup,31)
  else
     write(*,*) 'Wrong value for interaction'
     stop
  end if

! Generate gaussian quadrature points in q and p

  call gauss(0.d0,q0,qmax,nq,q,q2,wq)
  allocate(vec1(np1),vec2(np1),vec3(np1))
  call gauss(0.d0,p0,pmax,np1,vec1,vec2,vec3)
  allocate(vec4(np2),vec5(np2),vec6(np2))
  call gauss(pmax,pm,pcut,np2,vec4,vec5,vec6)
  p(1)=0.0_dp
  p2(1)=0.0_dp
  wp(1)=0.0_dp
  p(2:np1+1)=vec1(1:np1)
  p2(2:np1+1)=vec2(1:np1)
  wp(2:np1+1)=vec3(1:np1)
  p(np1+2:np1+np2+1)=vec4(1:np2)
  p2(np1+2:np1+np2+1)=vec5(1:np2)
  wp(np1+2:np1+np2+1)=vec6(1:np2)
  deallocate(vec1,vec2,vec3)
  deallocate(vec4,vec5,vec6)

! Generate the spline elements

  call spline(nptot,np,nq,nx,q,q2,p,x,wx,s1,s2)

! Generate the potential in momentum space

  if (interaction == 1 .or. interaction == 2) then
     call potential1(2,0,interaction,nptot,p,np_pot_0)        ! j=0 - neutron-proton
     call potential1(3,0,interaction,nptot,p,nn_pot_0)        ! j=0 - neutron-neutron
     call potential1(2,1,interaction,nptot,p,np_pot_1)        ! j=1 - neutron-proton
     call potential1(3,1,interaction,nptot,p,nn_pot_1)        ! j=1 - neutron-neutron
     call potential1(2,2,interaction,nptot,p,np_pot_2)        ! j=2 - neutron-proton
     call potential1(3,2,interaction,nptot,p,nn_pot_2)        ! j=2 - neutron-neutron
     call potential1(2,3,interaction,nptot,p,np_pot_3)        ! j=3 - neutron-proton
     call potential1(3,3,interaction,nptot,p,nn_pot_3)        ! j=3 - neutron-neutron
     call potential1(2,4,interaction,nptot,p,np_pot_4)        ! j=4 - neutron-proton
     call potential1(3,4,interaction,nptot,p,nn_pot_4)        ! j=4 - neutron-neutron
     call potential1(2,5,interaction,nptot,p,np_pot_5)        ! j=5 - neutron-proton
     call potential1(3,5,interaction,nptot,p,nn_pot_5)        ! j=5 - neutron-neutron
     call potential1(2,6,interaction,nptot,p,np_pot_6)        ! j=6 - neutron-proton
     call potential1(3,6,interaction,nptot,p,nn_pot_6)        ! j=6 - neutron-neutron
     call potential1(2,7,interaction,nptot,p,np_pot_7)        ! j=7 - neutron-proton
     call potential1(3,7,interaction,nptot,p,nn_pot_7)        ! j=7 - neutron-neutron
     call potential1(2,8,interaction,nptot,p,np_pot_8)        ! j=8 - neutron-proton
     call potential1(3,8,interaction,nptot,p,nn_pot_8)        ! j=8 - neutron-neutron
  else if (interaction == 3) then
     if (cutnumr == 1 .or. cutnumr == 2 .or. cutnumr == 3 .or. cutnumr == 4 .or. cutnumr == 5) then
        call potential2("np",0,0,cutnumr,nptot,p,np_pot_0)    ! j=0 - neutron-proton
        call potential2("nn",0,0,cutnumr,nptot,p,nn_pot_0)    ! j=0 - neutron-neutron
        call potential2("np",1,0,cutnumr,nptot,p,np_pot_1)    ! j=1 - neutron-proton
        call potential2("nn",1,0,cutnumr,nptot,p,nn_pot_1)    ! j=1 - neutron-neutron
        call potential2("np",2,0,cutnumr,nptot,p,np_pot_2)    ! j=2 - neutron-proton
        call potential2("nn",2,0,cutnumr,nptot,p,nn_pot_2)    ! j=2 - neutron-neutron
        call potential2("np",3,0,cutnumr,nptot,p,np_pot_3)    ! j=3 - neutron-proton
        call potential2("nn",3,0,cutnumr,nptot,p,nn_pot_3)    ! j=3 - neutron-neutron
        call potential2("np",4,0,cutnumr,nptot,p,np_pot_4)    ! j=4 - neutron-proton
        call potential2("nn",4,0,cutnumr,nptot,p,nn_pot_4)    ! j=4 - neutron-neutron
        call potential2("np",5,0,cutnumr,nptot,p,np_pot_5)    ! j=5 - neutron-proton
        call potential2("nn",5,0,cutnumr,nptot,p,nn_pot_5)    ! j=5 - neutron-neutron
        call potential2("np",6,0,cutnumr,nptot,p,np_pot_6)    ! j=6 - neutron-proton
        call potential2("nn",6,0,cutnumr,nptot,p,nn_pot_6)    ! j=6 - neutron-neutron
        call potential2("np",7,0,cutnumr,nptot,p,np_pot_7)    ! j=7 - neutron-proton
        call potential2("nn",7,0,cutnumr,nptot,p,nn_pot_7)    ! j=7 - neutron-neutron
        call potential2("np",8,0,cutnumr,nptot,p,np_pot_8)    ! j=8 - neutron-proton
        call potential2("nn",8,0,cutnumr,nptot,p,nn_pot_8)    ! j=8 - neutron-neutron
     else
        write(*,*) 'Wrong value for cutnumr in interaction=3'
        stop
     end if
  else
     write(*,*) 'Bad input for interaction'
     stop
  end if

! Set up the channels

  call channels(nchmax,chan)

! Set up the permutation operator

  write(*,32)
  write(*,33)
  call permutation(nchmax,nq,nx,chan,q,x,gfac)

! Set up the starting energy and the starting vector

  e    = zero
  e(1) = e0 / hbarc
  psi0 = one

! Solution of Faddeev equation

  write(*,34)
  write(*,35)
  write(oup,15)

  ie=0
  do
     ie=ie+1
     if (ie > iemax) then
        write(*,*) 'Too many iterations in the main loop'
        write(*,*) 'Parameter ie exceeded the value iemax'
        stop
     end if

     emev=e(ie)*hbarc
     if (ie < 10) then
        write(oup,16) ie,emev
     else if (ie >=10 .and. ie < 100) then
        write(oup,17) ie,emev
     else
        write(*,*) 'Error for ie parameter'
        stop
     end if

     ! Generates the two-body off-shell t matrices for all the q values

     do iq=1,nq
        e2=e(ie)-0.75_dp*q2(iq)/mf

        ! J = 0 in the NN sub-system
        call tsingle(1,nptot,np,e2,p2,wp,np_pot_0,tnp_s)
        call tsingle(1,nptot,np,e2,p2,wp,nn_pot_0,tnn_s)
        call tsingle(3,nptot,np,e2,p2,wp,np_pot_0,tnp_t)
        call tsingle(3,nptot,np,e2,p2,wp,nn_pot_0,tnn_t)
        do ip1=1,np
           do ip=1,np
              ts0(ip,ip1,iq) = (two/three)*tnn_s(ip,ip1) + (one/three)*tnp_s(ip,ip1)
              tt0(ip,ip1,iq) = (two/three)*tnn_t(ip,ip1) + (one/three)*tnp_t(ip,ip1)
           end do
        end do

        ! J = 1 in the NN sub-system
        call tsingle(1,nptot,np,e2,p2,wp,np_pot_1,tnp_s)
        call tsingle(2,nptot,np,e2,p2,wp,np_pot_1,tnp_t)
        call tsingle(2,nptot,np,e2,p2,wp,nn_pot_1,tnn_t)
        call tcoupled(nptot,np,e2,p2,wp,np_pot_1,tnp_pp,tnp_mm,tnp_pm,tnp_mp)
        do ip1=1,np
           do ip=1,np
              ts1(ip,ip1,iq)  = tnp_s(ip,ip1)
              tt1(ip,ip1,iq)  = (two/three)*tnn_t(ip,ip1) + (one/three)*tnp_t(ip,ip1)
              tmm1(ip,ip1,iq) = tnp_mm(ip,ip1)
              tmp1(ip,ip1,iq) = tnp_mp(ip,ip1)
              tpm1(ip,ip1,iq) = tnp_pm(ip,ip1)
              tpp1(ip,ip1,iq) = tnp_pp(ip,ip1)
           end do
        end do

        ! J = 2 in the NN sub-system
        call tsingle(1,nptot,np,e2,p2,wp,np_pot_2,tnp_s)
        call tsingle(1,nptot,np,e2,p2,wp,nn_pot_2,tnn_s)
        call tsingle(2,nptot,np,e2,p2,wp,np_pot_2,tnp_t)
        call tcoupled(nptot,np,e2,p2,wp,np_pot_2,tnp_pp,tnp_mm,tnp_pm,tnp_mp)
        call tcoupled(nptot,np,e2,p2,wp,nn_pot_2,tnn_pp,tnn_mm,tnn_pm,tnn_mp)
        do ip1=1,np
           do ip=1,np
              ts2(ip,ip1,iq)  = (two/three)*tnn_s(ip,ip1) + (one/three)*tnp_s(ip,ip1)
              tt2(ip,ip1,iq)  = tnp_t(ip,ip1)
              tmm2(ip,ip1,iq) = (two/three)*tnn_mm(ip,ip1) + (one/three)*tnp_mm(ip,ip1)
              tmp2(ip,ip1,iq) = (two/three)*tnn_mp(ip,ip1) + (one/three)*tnp_mp(ip,ip1)
              tpm2(ip,ip1,iq) = (two/three)*tnn_pm(ip,ip1) + (one/three)*tnp_pm(ip,ip1)
              tpp2(ip,ip1,iq) = (two/three)*tnn_pp(ip,ip1) + (one/three)*tnp_pp(ip,ip1)
           end do
        end do

        ! J = 3 in the NN sub-system
        call tsingle(1,nptot,np,e2,p2,wp,np_pot_3,tnp_s)
        call tsingle(2,nptot,np,e2,p2,wp,np_pot_3,tnp_t)
        call tsingle(2,nptot,np,e2,p2,wp,nn_pot_3,tnn_t)
        call tcoupled(nptot,np,e2,p2,wp,np_pot_3,tnp_pp,tnp_mm,tnp_pm,tnp_mp)
        do ip1=1,np
           do ip=1,np
              ts3(ip,ip1,iq)  = tnp_s(ip,ip1)
              tt3(ip,ip1,iq)  = (two/three)*tnn_t(ip,ip1) + (one/three)*tnp_t(ip,ip1)
              tmm3(ip,ip1,iq) = tnp_mm(ip,ip1)
              tmp3(ip,ip1,iq) = tnp_mp(ip,ip1)
              tpm3(ip,ip1,iq) = tnp_pm(ip,ip1)
              tpp3(ip,ip1,iq) = tnp_pp(ip,ip1)
           end do
        end do

        ! J = 4 in the NN sub-system
        call tsingle(1,nptot,np,e2,p2,wp,np_pot_4,tnp_s)
        call tsingle(1,nptot,np,e2,p2,wp,nn_pot_4,tnn_s)
        call tsingle(2,nptot,np,e2,p2,wp,np_pot_4,tnp_t)
        call tcoupled(nptot,np,e2,p2,wp,np_pot_4,tnp_pp,tnp_mm,tnp_pm,tnp_mp)
        call tcoupled(nptot,np,e2,p2,wp,nn_pot_4,tnn_pp,tnn_mm,tnn_pm,tnn_mp)
        do ip1=1,np
           do ip=1,np
              ts4(ip,ip1,iq)  = (two/three)*tnn_s(ip,ip1) + (one/three)*tnp_s(ip,ip1)
              tt4(ip,ip1,iq)  = tnp_t(ip,ip1)
              tmm4(ip,ip1,iq) = (two/three)*tnn_mm(ip,ip1) + (one/three)*tnp_mm(ip,ip1)
              tmp4(ip,ip1,iq) = (two/three)*tnn_mp(ip,ip1) + (one/three)*tnp_mp(ip,ip1)
              tpm4(ip,ip1,iq) = (two/three)*tnn_pm(ip,ip1) + (one/three)*tnp_pm(ip,ip1)
              tpp4(ip,ip1,iq) = (two/three)*tnn_pp(ip,ip1) + (one/three)*tnp_pp(ip,ip1)
           end do
        end do

        ! J = 5 in the NN sub-system
        call tsingle(1,nptot,np,e2,p2,wp,np_pot_5,tnp_s)
        call tsingle(2,nptot,np,e2,p2,wp,np_pot_5,tnp_t)
        call tsingle(2,nptot,np,e2,p2,wp,nn_pot_5,tnn_t)
        call tcoupled(nptot,np,e2,p2,wp,np_pot_5,tnp_pp,tnp_mm,tnp_pm,tnp_mp)
        do ip1=1,np
           do ip=1,np
              ts5(ip,ip1,iq)  = tnp_s(ip,ip1)
              tt5(ip,ip1,iq)  = (two/three)*tnn_t(ip,ip1) + (one/three)*tnp_t(ip,ip1)
              tmm5(ip,ip1,iq) = tnp_mm(ip,ip1)
              tmp5(ip,ip1,iq) = tnp_mp(ip,ip1)
              tpm5(ip,ip1,iq) = tnp_pm(ip,ip1)
              tpp5(ip,ip1,iq) = tnp_pp(ip,ip1)
           end do
        end do

        ! J = 6 in the NN sub-system
        call tsingle(1,nptot,np,e2,p2,wp,np_pot_6,tnp_s)
        call tsingle(1,nptot,np,e2,p2,wp,nn_pot_6,tnn_s)
        call tsingle(2,nptot,np,e2,p2,wp,np_pot_6,tnp_t)
        call tcoupled(nptot,np,e2,p2,wp,np_pot_6,tnp_pp,tnp_mm,tnp_pm,tnp_mp)
        call tcoupled(nptot,np,e2,p2,wp,nn_pot_6,tnn_pp,tnn_mm,tnn_pm,tnn_mp)
        do ip1=1,np
           do ip=1,np
              ts6(ip,ip1,iq)  = (two/three)*tnn_s(ip,ip1) + (one/three)*tnp_s(ip,ip1)
              tt6(ip,ip1,iq)  = tnp_t(ip,ip1)
              tmm6(ip,ip1,iq) = (two/three)*tnn_mm(ip,ip1) + (one/three)*tnp_mm(ip,ip1)
              tmp6(ip,ip1,iq) = (two/three)*tnn_mp(ip,ip1) + (one/three)*tnp_mp(ip,ip1)
              tpm6(ip,ip1,iq) = (two/three)*tnn_pm(ip,ip1) + (one/three)*tnp_pm(ip,ip1)
              tpp6(ip,ip1,iq) = (two/three)*tnn_pp(ip,ip1) + (one/three)*tnp_pp(ip,ip1)
           end do
        end do

        ! J = 7 in the NN sub-system
        call tsingle(1,nptot,np,e2,p2,wp,np_pot_7,tnp_s)
        call tsingle(2,nptot,np,e2,p2,wp,np_pot_7,tnp_t)
        call tsingle(2,nptot,np,e2,p2,wp,nn_pot_7,tnn_t)
        call tcoupled(nptot,np,e2,p2,wp,np_pot_7,tnp_pp,tnp_mm,tnp_pm,tnp_mp)
        do ip1=1,np
           do ip=1,np
              ts7(ip,ip1,iq)  = tnp_s(ip,ip1)
              tt7(ip,ip1,iq)  = (two/three)*tnn_t(ip,ip1) + (one/three)*tnp_t(ip,ip1)
              tmm7(ip,ip1,iq) = tnp_mm(ip,ip1)
              tmp7(ip,ip1,iq) = tnp_mp(ip,ip1)
              tpm7(ip,ip1,iq) = tnp_pm(ip,ip1)
              tpp7(ip,ip1,iq) = tnp_pp(ip,ip1)
           end do
        end do

        ! J = 8 in the NN sub-system
        call tsingle(1,nptot,np,e2,p2,wp,np_pot_8,tnp_s)
        call tsingle(1,nptot,np,e2,p2,wp,nn_pot_8,tnn_s)
        call tsingle(2,nptot,np,e2,p2,wp,np_pot_8,tnp_t)
        call tcoupled(nptot,np,e2,p2,wp,np_pot_8,tnp_pp,tnp_mm,tnp_pm,tnp_mp)
        call tcoupled(nptot,np,e2,p2,wp,nn_pot_8,tnn_pp,tnn_mm,tnn_pm,tnn_mp)
        do ip1=1,np
           do ip=1,np
              ts8(ip,ip1,iq)  = (two/three)*tnn_s(ip,ip1) + (one/three)*tnp_s(ip,ip1)
              tt8(ip,ip1,iq)  = tnp_t(ip,ip1)
              tmm8(ip,ip1,iq) = (two/three)*tnn_mm(ip,ip1) + (one/three)*tnp_mm(ip,ip1)
              tmp8(ip,ip1,iq) = (two/three)*tnn_mp(ip,ip1) + (one/three)*tnp_mp(ip,ip1)
              tpm8(ip,ip1,iq) = (two/three)*tnn_pm(ip,ip1) + (one/three)*tnp_pm(ip,ip1)
              tpp8(ip,ip1,iq) = (two/three)*tnn_pp(ip,ip1) + (one/three)*tnp_pp(ip,ip1)
           end do
        end do

     end do

     ! Initialization for the vector iteration

     iter = 0
     x1   = psi0
     rold = one
     write(oup,29)
     write(oup,30)
     do
        iter=iter+1
        if (iter > itermax) then
           write(*,*) 'Parameter iter exceeded the value itermax'
           stop
        end if

        ! Calculate Faddeev kernel and apply it to x1

        do iq=1,nq
           do ia2=1,nchmax
              do ip1=1,np
                 salph=zero
                 do ia1=1,nchmax
                    shh=zero
                    do iqp=1,nq
                       c1=0.25_dp*q2(iq)+q2(iqp)
                       c2=q2(iq)+0.25_dp*q2(iqp)
                       c3=q(iq)*q(iqp)
                       sh=zero
                       do ip2=1,np
                          s=zero
                          do ix=1,nx
                             pi1=sqrt(c1+c3*x(ix))
                             pi2=sqrt(c2+c3*x(ix))
                             s=s + wx(ix)*(s1(ix,ip1,iqp,iq)/(pi1**(chan(ia2,1)/2)))*gfac(ia2,ia1,iq,iqp,ix) &
                                 * (s2(ix,ip2,iqp,iq)/(pi2**(chan(ia1,1)/2)))
                          end do
                          sh=sh+s*x1(ia1,ip2,iqp)
                       end do
                       shh=shh+sh*wq(iqp)*q2(iqp)
                    end do
                    salph=salph+shh
                 end do
                 h(ia2,ip1)=salph
              end do
           end do
           do ip=1,np
              sumv=zero
              do ip1=1,np
                 sumv(1)  = sumv(1)  + ts0(ip,ip1,iq)*h(1,ip1)
                 sumv(2)  = sumv(2)  + tt0(ip,ip1,iq)*h(2,ip1)
                 sumv(3)  = sumv(3)  + ts1(ip,ip1,iq)*h(3,ip1)
                 sumv(4)  = sumv(4)  + ts1(ip,ip1,iq)*h(4,ip1)
                 sumv(5)  = sumv(5)  + tt1(ip,ip1,iq)*h(5,ip1)
                 sumv(6)  = sumv(6)  + tt1(ip,ip1,iq)*h(6,ip1)
                 sumv(7)  = sumv(7)  + tmm1(ip,ip1,iq)*h(7,ip1) + tmp1(ip,ip1,iq)*h(8,ip1)
                 sumv(8)  = sumv(8)  + tpm1(ip,ip1,iq)*h(7,ip1) + tpp1(ip,ip1,iq)*h(8,ip1)
                 sumv(9)  = sumv(9)  + tmm1(ip,ip1,iq)*h(9,ip1) + tmp1(ip,ip1,iq)*h(10,ip1)
                 sumv(10) = sumv(10) + tpm1(ip,ip1,iq)*h(9,ip1) + tpp1(ip,ip1,iq)*h(10,ip1)
                 sumv(11) = sumv(11) + ts2(ip,ip1,iq)*h(11,ip1)
                 sumv(12) = sumv(12) + ts2(ip,ip1,iq)*h(12,ip1)
                 sumv(13) = sumv(13) + tt2(ip,ip1,iq)*h(13,ip1)
                 sumv(14) = sumv(14) + tt2(ip,ip1,iq)*h(14,ip1)
                 sumv(15) = sumv(15) + tmm2(ip,ip1,iq)*h(15,ip1) + tmp2(ip,ip1,iq)*h(16,ip1)
                 sumv(16) = sumv(16) + tpm2(ip,ip1,iq)*h(15,ip1) + tpp2(ip,ip1,iq)*h(16,ip1)
                 sumv(17) = sumv(17) + tmm2(ip,ip1,iq)*h(17,ip1) + tmp2(ip,ip1,iq)*h(18,ip1)
                 sumv(18) = sumv(18) + tpm2(ip,ip1,iq)*h(17,ip1) + tpp2(ip,ip1,iq)*h(18,ip1)
                 sumv(19) = sumv(19) + ts3(ip,ip1,iq)*h(19,ip1)
                 sumv(20) = sumv(20) + ts3(ip,ip1,iq)*h(20,ip1)
                 sumv(21) = sumv(21) + tt3(ip,ip1,iq)*h(21,ip1)
                 sumv(22) = sumv(22) + tt3(ip,ip1,iq)*h(22,ip1)
                 sumv(23) = sumv(23) + tmm3(ip,ip1,iq)*h(23,ip1) + tmp3(ip,ip1,iq)*h(24,ip1)
                 sumv(24) = sumv(24) + tpm3(ip,ip1,iq)*h(23,ip1) + tpp3(ip,ip1,iq)*h(24,ip1)
                 sumv(25) = sumv(25) + tmm3(ip,ip1,iq)*h(25,ip1) + tmp3(ip,ip1,iq)*h(26,ip1)
                 sumv(26) = sumv(26) + tpm3(ip,ip1,iq)*h(25,ip1) + tpp3(ip,ip1,iq)*h(26,ip1)
                 sumv(27) = sumv(27) + ts4(ip,ip1,iq)*h(27,ip1)
                 sumv(28) = sumv(28) + ts4(ip,ip1,iq)*h(28,ip1)
                 sumv(29) = sumv(29) + tt4(ip,ip1,iq)*h(29,ip1)
                 sumv(30) = sumv(30) + tt4(ip,ip1,iq)*h(30,ip1)
                 sumv(31) = sumv(31) + tmm4(ip,ip1,iq)*h(31,ip1) + tmp4(ip,ip1,iq)*h(32,ip1)
                 sumv(32) = sumv(32) + tpm4(ip,ip1,iq)*h(31,ip1) + tpp4(ip,ip1,iq)*h(32,ip1)
                 sumv(33) = sumv(33) + tmm4(ip,ip1,iq)*h(33,ip1) + tmp4(ip,ip1,iq)*h(34,ip1)
                 sumv(34) = sumv(34) + tpm4(ip,ip1,iq)*h(33,ip1) + tpp4(ip,ip1,iq)*h(34,ip1)
                 sumv(35) = sumv(35) + ts5(ip,ip1,iq)*h(35,ip1)
                 sumv(36) = sumv(36) + ts5(ip,ip1,iq)*h(36,ip1)
                 sumv(37) = sumv(37) + tt5(ip,ip1,iq)*h(37,ip1)
                 sumv(38) = sumv(38) + tt5(ip,ip1,iq)*h(38,ip1)
                 sumv(39) = sumv(39) + tmm5(ip,ip1,iq)*h(39,ip1) + tmp5(ip,ip1,iq)*h(40,ip1)
                 sumv(40) = sumv(40) + tpm5(ip,ip1,iq)*h(39,ip1) + tpp5(ip,ip1,iq)*h(40,ip1)
                 sumv(41) = sumv(41) + tmm5(ip,ip1,iq)*h(41,ip1) + tmp5(ip,ip1,iq)*h(42,ip1)
                 sumv(42) = sumv(42) + tpm5(ip,ip1,iq)*h(41,ip1) + tpp5(ip,ip1,iq)*h(42,ip1)
                 sumv(43) = sumv(43) + ts6(ip,ip1,iq)*h(43,ip1)
                 sumv(44) = sumv(44) + ts6(ip,ip1,iq)*h(44,ip1)
                 sumv(45) = sumv(45) + tt6(ip,ip1,iq)*h(45,ip1)
                 sumv(46) = sumv(46) + tt6(ip,ip1,iq)*h(46,ip1)
                 sumv(47) = sumv(47) + tmm6(ip,ip1,iq)*h(47,ip1) + tmp6(ip,ip1,iq)*h(48,ip1)
                 sumv(48) = sumv(48) + tpm6(ip,ip1,iq)*h(47,ip1) + tpp6(ip,ip1,iq)*h(48,ip1)
                 sumv(49) = sumv(49) + tmm6(ip,ip1,iq)*h(49,ip1) + tmp6(ip,ip1,iq)*h(50,ip1)
                 sumv(50) = sumv(50) + tpm6(ip,ip1,iq)*h(49,ip1) + tpp6(ip,ip1,iq)*h(50,ip1)
                 sumv(51) = sumv(51) + ts7(ip,ip1,iq)*h(51,ip1)
                 sumv(52) = sumv(52) + ts7(ip,ip1,iq)*h(52,ip1)
                 sumv(53) = sumv(53) + tt7(ip,ip1,iq)*h(53,ip1)
                 sumv(54) = sumv(54) + tt7(ip,ip1,iq)*h(54,ip1)
                 sumv(55) = sumv(55) + tmm7(ip,ip1,iq)*h(55,ip1) + tmp7(ip,ip1,iq)*h(56,ip1)
                 sumv(56) = sumv(56) + tpm7(ip,ip1,iq)*h(55,ip1) + tpp7(ip,ip1,iq)*h(56,ip1)
                 sumv(57) = sumv(57) + tmm7(ip,ip1,iq)*h(57,ip1) + tmp7(ip,ip1,iq)*h(58,ip1)
                 sumv(58) = sumv(58) + tpm7(ip,ip1,iq)*h(57,ip1) + tpp7(ip,ip1,iq)*h(58,ip1)
                 sumv(59) = sumv(59) + ts8(ip,ip1,iq)*h(59,ip1)
                 sumv(60) = sumv(60) + ts8(ip,ip1,iq)*h(60,ip1)
                 sumv(61) = sumv(61) + tt8(ip,ip1,iq)*h(61,ip1)
                 sumv(62) = sumv(62) + tt8(ip,ip1,iq)*h(62,ip1)
                 sumv(63) = sumv(63) + tmm8(ip,ip1,iq)*h(63,ip1) + tmp8(ip,ip1,iq)*h(64,ip1)
                 sumv(64) = sumv(64) + tpm8(ip,ip1,iq)*h(63,ip1) + tpp8(ip,ip1,iq)*h(64,ip1)
                 sumv(65) = sumv(65) + tmm8(ip,ip1,iq)*h(65,ip1) + tmp8(ip,ip1,iq)*h(66,ip1)
                 sumv(66) = sumv(66) + tpm8(ip,ip1,iq)*h(65,ip1) + tpp8(ip,ip1,iq)*h(66,ip1)
              end do
              fdenom=e(ie) - 0.75_dp*q2(iq)/mf - p2(ip)/mf
              do ic=1,nchmax
                 x2(ic,ip,iq)=sumv(ic)/fdenom
              end do
           end do
        end do

        ! The new vector x2 has been found after the application ot the
        ! faddeev kernel to the old vector x1
        ! Now it calculates the ratio between x2 and x1

        do iq=1,nq
           do ip=1,np
              do ia=1,nchmax
                 rnew(ia,ip,iq)=x2(ia,ip,iq)/x1(ia,ip,iq)
              end do
           end do
        end do
        ratmax=0.5_dp
        ratmin=2.0_dp
        do iq=1,nq
           do ip=1,np
              do ia=1,nchmax
                 if (rnew(ia,ip,iq) > ratmax) ratmax=rnew(ia,ip,iq)
                 if (rnew(ia,ip,iq) < ratmin) ratmin=rnew(ia,ip,iq)
              end do
           end do
        end do
        write(oup,18) iter,ratmin,rnew(iaf,ipf,iqf),ratmax

        ! Parameter df is taken as a measure for the convergence of the vector iteration at each energy

        df=(rnew(iaf,ipf,iqf)-rold(iaf,ipf,iqf))/rold(iaf,ipf,iqf)
        if (abs(df) < 1.0E-7) exit

        x1   = x2
        rold = rnew

     end do ! End loop over iter

     ! Parameter eta is the approximate eigenvalue of the faddeev kernel

     eta(ie)=rnew(iaf,ipf,iqf)

     if (ie < 10) then
        write(oup,19) ie,e(ie),ie,eta(ie)
     else if (ie >=10 .and. ie < 100) then
        write(oup,25) ie,e(ie),ie,eta(ie)
     else
        write(*,*) 'Error for ie parameter'
        stop
     end if

     ! The energy eig(ie) vanishes at the binding energy

     eig(ie)=eta(ie)-1.0_dp
     if (ie < 10) then
        write(oup,20) ie,eig(ie)
     else if (ie >=10 .and. ie < 100) then
        write(oup,28) ie,eig(ie)
     else
        write(*,*) 'Error for ie parameter'
        stop
     end if
     
     if (abs(eig(ie)) < 1.0E-6) exit

     ! Energy search

     do ia=1,nchmax
        do ip=1,np
           do iq=1,nq
              psi0(ia,ip,iq)=x2(ia,ip,iq)
           end do
        end do
     end do
     if (ie == 1) then
        e(ie+1)=e(ie)+de/hbarc
        cycle
     else
        call search(eig(ie-1),eig(ie),e(ie-1),e(ie),e(ie+1),de)
        cycle
     end if

  end do ! End loop over ie

! Print the result in the output file

  write(oup,*)
  write(oup,*)
  write(oup,21)
  write(oup,22)
  write(oup,23) emev
  write(oup,24)

! Print the result on the terminal

  write(*,21)
  write(*,22)
  write(*,23) emev
  write(*,24)

! Format statements

  10 format(32(1h*),1x,'INPUT PARAMETERS',1x,32(1h*),/)
  11 format(2x,'np1 =',i3,5x,'np2 =',i3,5x,'nptot =',i3,5x,'np =',i3,5x,'nq =',i3,5x,'nx =',i3/)
  12 format(2x,'q0 = ',f5.2,1x,'[fm^1]',6x,'qmax = ',f5.2,1x,'[fm^1]'/)
  13 format(2x,'p0 = ',f5.2,1x,'[fm^1]',6x,'pmax = ',f5.2,1x,'[fm^1]'/)
  14 format(2x,'pm = ',f5.2,1x,'[fm^1]',6x,'pcut = ',f5.2,1x,'[fm^1]'/)
  15 format(35(1h*),1x,'ITERATIONS',1x,35(1h*),/)
  16 format(2x'e(',i1,') = ',e14.7,2x,'[MeV]'/)
  17 format(2x'e(',i2,') = ',e14.7,2x,'[MeV]'/)
  18 format(i10,3e15.6)
  19 format(/,8x,'e(',i1,') = ',e14.7,2x,'[fm^-1]',8x,'eta(',i1,') =',e12.5/)
  20 format(8x,'eig('i1') =',1x,e12.5,///)
  21 format(5x,47(1h*))
  22 format(5x,'***',11x,'Iteration converged',11x,'***')
  23 format(5x,'***',2x,'Triton binding energy = ',e14.7,1x,'MeV',2x,'***')
  24 format(5x,47(1h*))
  25 format(/,8x,'e(',i2,') = ',e14.7,2x,'[fm^-1]',8x,'eta(',i2,') =',e12.5/)
  26 format(2x,'Interaction:',3x,'CD-Bonn 2000',/)
  27 format(2x,'Interaction:',3x,'N4LO(500) EMN of 2017',/)
  28 format(8x,'eig('i2') =',1x,e12.5,///)
  29 format(6x,'iter',6x,'Ratmin',9x,'Ratio',10x,'Ratmax')
  30 format(6x,49(1h-))
  31 format(2x,'Interaction:',3x,'N4LO(500) EKM of 2014',/)
  32 format(1x,'Compute the permutation operator')
  33 format(1x,'--------------------------------')
  34 format(/,1x,'Solve the Faddeev equation')
  35 format(1x,'--------------------------',/)

! Close output file

  close(oup)

end program triton