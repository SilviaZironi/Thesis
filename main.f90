program trimod
use nrtype
use constants
use interpolation
use trimod_sub
implicit none
!--------------------------------------------------------------------------------------------------------------------------------!
! The output file is automatically generated by the program and it is called output.dat
!
! Parameters:
!
!    nq  = number of q points in the interval [0,qmax] with q0 beeing the middle
!    np1 = number of p points in the interval [0,pmax] with p0 beeing the middle
!    np2 = number of p points in the interval [pmax,pcut] with pm beeing the middle
!    nptot = total number of p points as needed for the solution of the Lippmann-Schwinger equation in tmat
!    np  = number of p points for the spline interpolation
!    nx  = number of x points in the interval [-1.0,1.0]
!    m   = nucleon mass in MeV (defined in module constants)
!    mf  = nucleon mass in fm^-1 (defined in module constants)
!    e0  = starting energy in MeV
!    de  = energy step in MeV (defined in module constants)
!    ipf,iqf = indices for arbitrarily chosen p and q points for the vector iteration procedure
!
!
! Principal global variables:
!
!    q = array of q points
!    p = array of p points
!    s1,s2 = spline elements
!    psi0  = starting vector at each energy
!    x1,x2 = vectors, x2 results from application ot the Faddeev kernel to x1
!    rold,rnew = ratios of x2 and x1
!    e   = energy values during the energy search
!    eta = eigenvalue ot the Faddeev kernel
!    t   = the two-body off-shell t-matrix
!    ratmax,ratmin = the maximal and minimum ratios of x2 and x1 with respect to p and q variations
!--------------------------------------------------------------------------------------------------------------------------------!
integer(kind=i4b), parameter :: nq=10,np1=16,np2=18,nptot=1+np1+np2,np=np1+1,nx=10,ipf=8,iqf=5,iemax=10,itermax=30
real(kind=dp), parameter :: q0=1.0_dp,qmax=4.0_dp,p0=1.0_dp,pmax=1.5_dp*qmax+0.3_dp,pm=10.0_dp,pcut=50.0_dp,e0=-7.4_dp
integer(kind=i4b) :: ie,ip,ip1,ip2,ipp,iq,iqp,iter,ix
real(kind=dp) :: df,e2,emev,ratmax,ratmin,s,sh,shh,shhh
real(kind=dp), dimension(nq) :: q,q2,wq
real(kind=dp), dimension(np1) :: aux1,aux2,aux3
real(kind=dp), dimension(np2) :: aux4,aux5,aux6
real(kind=dp), dimension(nptot) :: p,p2,wp
real(kind=dp), dimension(nx) :: x,wx
real(kind=dp), dimension(nx,np,nq,nq) :: s1,s2
real(kind=dp), dimension(nptot,nptot) :: v,th
real(kind=dp), dimension(np,nq) :: psi0,x1,x2,rold,rnew
real(kind=dp), dimension(10) :: e,eta,eig
real(kind=dp), dimension(np) :: h
real(kind=dp), dimension(nptot,nptot,nq) :: t
real(kind=dp), dimension(2) :: v0, a
integer :: ios

! Open output file

  open(oup,file='output.dat',status='replace')

! Write input parameters in the output file

  write(oup,10)
  write(oup,11) np1,np2,nptot
  write(oup,12) nq,qmax,nx
  write(oup,13) p0,pmax,pm,pcut
  write(oup,14)

! Generate gaussian quadrature points in q and p

  call gauss(0.d0,q0,qmax,nq,q,q2,wq)
  call gauss(0.d0,p0,pmax,np1,aux1,aux2,aux3)
  call gauss(pmax,pm,pcut,np2,aux4,aux5,aux6)
  p(1)=0.0_dp
  p2(1)=0.0_dp
  wp(1)=0.0_dp
  p(2:np1+1)=aux1(1:np1)
  p2(2:np1+1)=aux2(1:np1)
  wp(2:np1+1)=aux3(1:np1)
  p(np1+2:np1+np2+1)=aux4(1:np2)
  p2(np1+2:np1+np2+1)=aux5(1:np2)
  wp(np1+2:np1+np2+1)=aux6(1:np2)

! Generate the spline elements

  call spline(nptot,np,nq,nx,q,q2,wq,p,wp,x,wx,s1,s2)

! --- parametri del potenziale: default + lettura da file ---
v0 = (/ -570.316_dp, 1438.4812_dp /)
a  = (/   1.55_dp,      3.11_dp    /)

open(unit=99, file='params.in', status='old', action='read', iostat=ios)
if (ios == 0) then
   read(99,*,iostat=ios) v0(1), v0(2), a(1), a(2)
   close(99)
end if

! (opzionale) scrivi i parametri usati nel file di output
write(oup,'(2x,"v0 = ",2f12.6, 5x, "a = ",2f12.6)') v0(1), v0(2), a(1), a(2)

! Generate the potential in momentum space

  call pot(nptot, p, p2, wp, v, v0, a)

! Set up the starting energy and the starting vector

  e(1)=(e0/hbarc)*mf
  do iq=1,nq
     do ip=1,np
        psi0(ip,iq)=1.0_dp
     end do
  end do

! Solution of Faddeev equations

  ie=0
  do
     ie=ie+1
     if (ie > iemax) then
        write(*,*) 'Too many iterations in the main loop'
        write(*,*) 'Parameter ie exceeded the value iemax'
        stop
     end if

     emev=e(ie)*hbarc/mf
     write(oup,15) emev

     ! Generates the two-body off-shell t matrix for all the q values

     do iq=1,nq
        e2=e(ie)-0.75_dp*q2(iq)
        call tmat(e2,nptot,p,p2,wp,v,th)
        do ip=1,nptot
           do ipp=1,nptot
              t(ip,ipp,iq)=th(ip,ipp)
           end do
        end do
     end do

     ! Initialisation for the vector iteration

     iter=0
     do iq=1,nq
        do ip=1,np
           x1(ip,iq)=psi0(ip,iq)
           rold(ip,iq)=1.0_dp
        end do
     end do

     do
        iter=iter+1
        if (iter > itermax) then
           write(*,*) 'Parameter iter exceeded the value itermax'
           stop
        end if

        do iq=1,nq
           do ip1=1,np
              shh=0.0_dp
              do iqp=1,nq
                 sh=0.0_dp
                 do ip2=1,np
                    s=0.0_dp
                    do ix=1,nx
                       s=s+wx(ix)*s1(ix,ip1,iqp,iq)*s2(ix,ip2,iqp,iq)
                    end do
                    sh=sh+s*x1(ip2,iqp)
                 end do
                 shh=shh+sh*wq(iqp)
              end do
              h(ip1)=shh
           end do
           do ip=1,np
              shhh=0.0_dp
              do ip1=1,np
                 shhh=shhh+t(ip,ip1,iq)*h(ip1)
              end do
              x2(ip,iq)=shhh/(e(ie)-0.75_dp*q2(iq)-p2(ip))
           end do
        end do

        ! The new vector x2 has been found after the application ot the
        ! faddeev kernel to the old vector x1

        do ip=1,np
           do iq=1,nq
              rnew(ip,iq)=x2(ip,iq)/x1(ip,iq)
           end do
        end do
        ratmax=0.5_dp
        ratmin=2.0_dp
        do ip=1,np
           do iq=1,nq
              if (rnew(ip,iq) > ratmax) ratmax=rnew(ip,iq)
              if (rnew(ip,iq) < ratmin) ratmin=rnew(ip,iq)
           end do
        end do
        if (iter > 1) write(oup,16) iter,ratmin,rnew(ipf,iqf),ratmax

        ! Parameter df is taken as a measure for the convergence of the vector iteration at each energy

        df=(rnew(ipf,iqf)-rold(ipf,iqf))/rold(ipf,iqf)
        if (abs(df) < 1.0E-7) exit

        do ip=1,np
           do iq=1,nq
              x1(ip,iq)=x2(ip,iq)
              rold(ip,iq)=rnew(ip,iq)
           end do
        end do
     end do

     eta(ie)=rnew(ipf,iqf)

     ! Parameter eta is the approximate eigenvalue of the faddeev kernel

     write(oup,17) ie,e(ie),eta(ie)

     ! The energy eig(ie) vanishes at the binding energy

     eig(ie)=eta(ie)-1.0_dp
     write(oup,18) eig(ie)
     if (abs(eig(ie)) < 1.0E-6) exit

     ! Energy search

     do ip=1,np
        do iq=1,nq
           psi0(ip,iq)=x2(ip,iq)
        end do
     end do
     if (ie == 1) then
        e(ie+1)=e(ie)+(de/hbarc)*mf
        cycle
     else
        call search(eig(ie-1),eig(ie),e(ie-1),e(ie),e(ie+1))
        cycle
     end if
  end do

! Print the result in the output file

  write(oup,*)
  write(oup,*)
  write(oup,19)
  write(oup,20)
  write(oup,21) emev
  write(oup,22)

! Print the result on the terminal

  write(*,19)
  write(*,20)
  write(*,21) emev
  write(*,22)

! Format statements

  10 format(32(1h*),1x,'INPUT PARAMETERS',1x,32(1h*),/)
  11 format(2x,'np1 =',i3,5x,'np2 =',i3,5x,'nptot =',i3/)
  12 format(2x,'nq =',i3,6x,'qmax = ',e9.3,5x,'nx =',i3/)
  13 format(2x,'p0 = ',e9.3,5x,'pmax = ',e9.3,5x,'pm = ',e9.3,5x,'pcut = ',e9.3/)
  14 format(35(1h*),1x,'ITERATIONS',1x,35(1h*))
  15 format(/,5x'emev = ',e12.5/)
  16 format(i10,3e15.6)
  17 format(/5x,'ie =',i3,5x,'e(ie) =',e12.5,5x,'eta(ie) =',e12.5/)
  18 format(/10x,'eig(ie)  =',e12.5/)
  19 format(5x,47(1h*))
  20 format(5x,'***',11x,'Iteration converged',11x,'***')
  21 format(5x,'***',2x,'3-body binding energy = ',f9.6,1x,'MeV',2x,'***')
  22 format(5x,47(1h*))

! Close output file

  close(oup)

end program trimod